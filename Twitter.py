# -*- coding: utf-8 -*-
"""Untitled50.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/DEEPESH98/Machine-Larning/blob/master/twitter.ipynb
"""

from ast import keyword
from errno import ENOMSG
from itertools import count
from turtle import position
from numpy import positive
import tweepy
from textblob import TextBlob
import matplotlib.pyplot as plt
import time


# all 4 authentication keys to access twitter API

# to connect as OAth handler or jump serever / revers proxy server
consumer_key= "0qmkiiimvySwoJXJ2O472od7d"
consumer_sec = "oXhGMiIEjPffzVRzM6Dg5Oc4Lr26enikCOOO9OqzqvPGXFB7hS"
# from proxy server we need to connect
access_token = "1527910641847398400-AzW5U8yoLN0eg0ibdGnvISC7LeSzAO"
access_token_sec = "79vVNGBE6rzJ22Z2tmWc1x2vuZ07NLQjGIfbKB57GWvnb"

def authentication():
   # connected to jump server of twitter
   auth=tweepy.OAuthHandler(consumer_key,consumer_sec)

   # now we can connect from jump server to web server of twitter
   auth.set_access_token(access_token,access_token_sec)

   # now we can connect to API storge server of twitter
   api_connect=tweepy.API(auth)

   return api_connect


def get_tweets(api,keyword,noOfTweets):
   # now you can search any topic on twitter
   tweet_data=api.search_tweets(keyword,count=noOfTweets)

   return tweet_data

def sentiment_tweets(tweet_data):
   pos = 0
   neg = 0 
   neu = 0
   # printing line by line
   for tweet in tweet_data:
      # here will apply Natural language processing to process tweets sentiments
      analysis=TextBlob(tweet.text) 
      # now checking polarity
      if analysis.sentiment.polarity > 0:
         #print("Sentiment status : positive")
         pos=pos+1
      elif analysis.sentiment.polarity == 0 :
         #print("Sentiment status : Neutral")
         neu=neu+1
      else :
         #print("Sentiment status : Negative")
         neg=neg+1

   return pos,neg,neu
        
def print_tweets(tweet_data):
  
   for tweet in tweet_data:
      print(f"\n{tweet.text}")
      line_break="====="*20
      print(line_break)
   
   

def plotting_pieChart(pos,neg,neu):
   # ploting graphs
   plt.xlabel(f"Total Tweets {pos+neg+neu}")
   #plt.bar(['pos','neg','neu'],[pos,neg,neu])
   plt.pie([pos,neg,neu],labels=[f'positive tweets : {pos}',f'negative tweets : {neg}',f'neutral tweets : {neu}'],autopct="%2.1f%%")
   plt.show()
if __name__ == "__main__":
   #taking input as a keyword from user
   keyword = input("Enter a keyword for getting Tweets: ")
   noOfTweets = int(input("Enter the length of tweets list (max limit 100): "))

   #calling authentication function to authenticate the keys with API
   api = authentication()

   #calling get tweets function to get all the tweets related to keyword
   tweet_data = get_tweets(api,keyword,noOfTweets)

   #printing all the tweets related to keyword
   print_tweets(tweet_data)
   print("~~~~~~"*20)
   print(f"\nTweets found related to {keyword} is : {len(tweet_data)}")

   #calling sentiments tweets function to get the sentiments of each tweets this method initialize the textblob class which perform Natural language processing
   positive_tweets = sentiment_tweets(tweet_data)[0]
   negative_tweets = sentiment_tweets(tweet_data)[1]
   neutral_tweets  = sentiment_tweets(tweet_data)[2]
   
   #After analysis printing stats of tweets
   print(f"Positivie tweets value out of {len(tweet_data)} is : {positive_tweets}\n")

   print(f"Negative tweets value out of {len(tweet_data)} is : {negative_tweets}\n")

   print(f"Neutral tweets value out of {len(tweet_data)} is : {neutral_tweets}")

   #plotting pie chart 
   plotting_pieChart(positive_tweets,negative_tweets,neutral_tweets)
